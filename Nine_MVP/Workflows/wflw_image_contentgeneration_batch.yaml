# This is the main workflow to generate image contents in batch
#

main:
  steps:
    # Step 1: initialize varibales
    - init:
        assign:
            - PROJECT: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
            - LOCATION: "us-central1"
 
            
            - CONTENT_METHOD: "batchPredictionJobs" 
            - CONTENT_LLM_API_ENDPOINT: ${"https://" + LOCATION + "-aiplatform.googleapis.com" + "/v1/projects/" + PROJECT + "/locations/" + LOCATION + "/"+CONTENT_METHOD}
            - MODEL: "publishers/google/models/gemini-1.5-flash-002"
            - MEDIA_TYPES: ['image/jpeg', 'image/png'] 
            - SOURCE_BUCKET: "raw_nine_files"
            - DESTINATION_BUCKET: "artifacts-nine-quality-test-embeddings"
            - FUNC_CREATE_GCS_BATCH_REQUEST: ${"https://"+LOCATION+"-"+PROJECT+".cloudfunctions.net/func_create_batchrequest_file"}
            - REQUEST_FILE_PREFIX: "request"
            - REQUEST_FOLDER: "batch_request_fldr"
            - BATCH_PREDICTION_FOLDER: "batch_prediction_fldr_out"
            
            - IMAGE_PROMPT_TEXT: "You are an assistant tasked with summarizing images for retrieval. \
                                These summaries will be embedded and used to retrieve the raw image. \
                                Give a concise summary of the image that is well optimized for retrieval.\
                                If there is a famous person like politician, celebrity or athlete, indicate their name and describe what they are famous for.\
                                If you are not sure about any info, please do not make it up. Do not add any extra text to the output."
            - TEMPERATURE: 0.5
            - MAX_OUT_TOKENS: 2048
            - TOP_P: 0.8
            - TOP_K: 40

    # Step 2: List objects in the GCS bucket
    - list_files:
        call: googleapis.storage.v1.objects.list
        args:
          bucket: ${SOURCE_BUCKET}
        result: list_result
 
   
    # Step 3: Filter only images and create json batch requests  
    - create_batch_json_request:
        steps:
           - assignList:
              assign: 
                  - filetered_files: []
                  - batch_requests: []
           - loopList:
              for:
                  value: item
                  in: ${list_result.items}
                  steps:
                      - check_matching: 
                          switch:                        
                            - condition: ${item.contentType in MEDIA_TYPES}  
                              steps:
                                        - add_matching_item_to_filetered_list:
                                            assign:                                             
                                                - image_uri: ${"gs://"+SOURCE_BUCKET+"/"+item.name} 
                                                - image_uri_map: {"gcs_uri": "${image_uri}"}                                    
                                                - item: ${map.merge(item, image_uri_map)} 
                                                - json_item:
                                                    request:
                                                        contents:
                                                           role: "user"
                                                           parts:
                                                            - fileData:
                                                                mimeType:  ${item.contentType}
                                                                fileUri: ${item.gcs_uri}
                                                            - text: ${IMAGE_PROMPT_TEXT}
                                                        generation_config:
                                                            temperature: ${TEMPERATURE}
                                                            max_output_tokens: ${MAX_OUT_TOKENS}
                                                            top_p: ${TOP_P}
                                                            top_k: ${TOP_K}
                                                        safety_settings: 
                                                            [   
                                                                {category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                                                  threshold: "BLOCK_NONE"
                                                                },
                                                                {category: "HARM_CATEGORY_HATE_SPEECH",
                                                                  threshold: "BLOCK_NONE"
                                                                },
                                                                 {category: "HARM_CATEGORY_HARASSMENT",
                                                                  threshold: "BLOCK_NONE"
                                                                },
                                                                 {category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                                                                  threshold: "BLOCK_NONE"
                                                                }
                                                            ] 
                                                - batch_requests: ${list.concat(batch_requests, json_item)}
  
            
    # Step 4: Encode batch request as a json     
    - encode_batch_requests:
        assign:
          - encoded_request: ${json.encode(batch_requests)}     
    
    # Step 5: Create batch request file in gcs
    - genearte_batch_request_file:
        call: http.post
        args:
            url: ${FUNC_CREATE_GCS_BATCH_REQUEST}
            query:
                name: "CREATE BATCH REQUEST FILE"            
                bucket: ${DESTINATION_BUCKET}
                request_file_prefix: ${REQUEST_FILE_PREFIX}
                request_body:   ${ text.decode(encoded_request, "UTF-8")} 
                request_file_folder: ${REQUEST_FOLDER}
        result:  request_file_res

    # Step 6: Set request/response file name/location
    - set_request_response_locations:
        assign:
            - source_file: ${"gs://"+DESTINATION_BUCKET+"/"+request_file_res.body.request_file_name}
            - destination_folder: ${"gs://"+DESTINATION_BUCKET+"/"+BATCH_PREDICTION_FOLDER}

    # Step 7: Extract image contents by sending a batch prediction job                             
    - create_batch_request_job:        
                steps:
                    - ask_llm:
                        call: http.post
                        args:
                            url: ${CONTENT_LLM_API_ENDPOINT}
                            auth:
                                type: OAuth2
                            body:
                               
                                displayName: "BP_JOB_IMAGE_CONTENT_GENERATOR"
                                model: ${MODEL}
 
                                inputConfig: {
                                        instancesFormat:"jsonl",
                                        gcsSource:{  
                                                uris : "${source_file}"
                                                 }
                                            }
                                 
                                outputConfig: {
                                        predictionsFormat:"jsonl",
                                        gcsDestination:{
                                             outputUriPrefix: "${destination_folder}"
                                              }
                                          }
                                          
                        result: llm_response 

    # Step 8: Get the job status 
    - get_job_status:    
        call: googleapis.aiplatform.v1.projects.locations.batchPredictionJobs.get
        args:
            name:  ${llm_response.body.name}
            region: ${LOCATION}     
       
        result: listResult
    
    # Step 9: check the job status if succeeded or failed return
    - checkIfDone:
            switch:
              - condition: ${listResult.state=="JOB_STATE_SUCCEEDED"}
                return: {output_dir: "${listResult.outputInfo.gcsOutputDirectory}", state:"JOB_STATE_SUCCEEDED" } 

              - condition: ${listResult.state=="JOB_STATE_FAILED"}
                return:  {output_dir: "", state:"JOB_STATE_FAILED" } 

    # Step 10: if job status is not  succeeded or failed, sleep for 120 seconds and check it again
    - wait:
            call: sys.sleep
            args:
                seconds: 120
            next: get_job_status
 

 


 
